# 6-01. 리덕스 사용 시 따라야 할 3가지 원칙

> 목차

- [Redux를 사용하는 이유](#redux를-사용하는-이유)
- [Redux를 사용원칙 3가지](#redux를-사용원칙-3가지)
    - [1. 전체 상태값을 하나의 객체에 저장한다.](#1-전체-상태값을-하나의-객체에-저장한다)
    - [2. 상태값은 불변 객체이다.](#2-상태값은-불변-객체이다)
        - [action 객체의 속성](#action-객체의-속성)
        - [리덕스의 상탯값을 수정하는 방법](#리덕스의-상탯값을-수정하는-방법)
    - [3. 상태값은 순수 함수에 의해서만 변경되어야 한다.](#3-상태값은-순수-함수에-의해서만-변경되어야-한다)

## Redux를 사용하는 이유

- 서버가 렌더링될 때, 데이터 전달이 간편하다.
- 로컬 스토리지에 데이터를 저장하고 불러오는 코드를 쉽게 작성할 수 있다.
- 컴포넌트 코드로부터 상태 관리 코드를 분리할 수 있다.
- 같은 상태값을 다수의 컴포넌트에서 필요로 할 때 편리하다.
- 부모 컴포넌트에서 깊은 곳에 있는 자식 컴포넌트에게 상태값을 전달할 때 편리하다.
- 알림창과 같은 전역 컴포넌트의 상태값을 관리할 때 좋다
- 페이지가 전환되어도 데이터는 살아 있어야 할 때 사용하면 좋다.

## Redux를 사용원칙 3가지

### 1. 전체 상태값을 하나의 객체에 저장한다.

> 하나의 객체에 프로그램의 전체 상탯값을 저장한다.

전체 상태값이 하나의 자바스크립트 객체로 표현되기 때문에 활용도가 높아진다.
리덕스를 사용하면 하나의 객체를 직렬화해서 서버와 클라이언트가 프로그램의 전체 상탯값을 서로 주고받을 수 있다. 따라서 프로그램이 특정한 상태에 있을 때 발생하는 버그를 확인하기 위해 그 상탯값을 저장한 후 반복해서 재현할 수 있다.

하지만 프로그램의 전체 상탯값을 리덕스로 관리하는 것만이 쉽지는 않다.
애니메이션을 위한 데이터나 문자열 입력창의 현재 상탯값은 컴포넌트 자체에서 관리하는게 더 나을 수도 있기 때문에 프로그램에서 다루는 일부 상태만 리덕스로 활용해도 된다.

전체 상태값을 리덕스로 관리하면 시간여행과 같은 기능을 쉽게 구현할 수도 있지만, 그런 기능을 사용하지 않을거라면 필요한 곳에서만 리덕스를 하용하면 된다

> Q. 시간여행 기능

### 2. 상태값은 불변 객체이다.

> 상탯값을 불변 객체로 관리한다.

상탯값은 오직 action객체에 의해서만 변경되어야 한다.

```js
const incrementAction = {
  type: 'INCREMENT',
  amount: 123,
}

const conditionalIncrementAction = {
  type: 'CONDITIONAL_INCREMENT',
  amount: 2,
  gt: 10,
  lt: 100,
}

store.dispatch(incrementAction);
store.dispatch(conditionalIncrementAction);
```

#### action 객체의 속성

1. action객체는 type 속성값이 존재해야 한다. 이러한 type 속성값으로 action객체를 구분한다.
2. type 속성값을 제외한 나머지는 상탯값을 수정하기 위한 정보이다.
3. action객체와 함께 dispatch 메서드를 호출하면 상탯값이 변경된다.

#### 리덕스의 상탯값을 수정하는 방법

action객체와 함께 dispatch 메서드를 호출하는 것만 유일한 방법이다. 다른 어떤 방법으로도 상탯값을 수정하면 안된다.

상탯값을 dispatch 메서드가 호출된 순서대로 리덕스 내부에서 변경되기 때문에 상탯값이 변화되는 과정을 쉽게 이해할 수 있다. 또한 action객체는 평범한 자바스크립트 객체이기 때문에 입력된 순서를 저장해 놓고, 나중에 그 과정을 쉽게 재현할 수도 있다.

상탯값 수정이라는 목적만 본다면 ~~불변 객체를 사용하는 것보다는~~ 상탯값을 직접 수정하는 것이 더 빠르겠지만, 이전 상탯값과 이후 상탯값을 비교해서 변경 여부를 파악할 때에는 불변 객체가 더 유리하다. 이렇게 상탯값 변경을 빠르게 확인할 수 있으면 메모이제이션와 같은 기능을 활용하기 좋고, 리액트의 렌더링 성능을 올리는 최적화하는 데에도 유리하다.

### 3. 상태값은 순수 함수에 의해서만 변경되어야 한다.

리덕스에서 상탯값을 변경하는 함수를 `리듀서(Reducdr)`라고 한다.

```js
// reducer의 구조
(state, action) => newState
```

리듀서는 이전 상탯값과 액션 객체를 입력으로 받아와서 새로운 상탯값을 만드는 순수함수이다.

순수함수는 ~~전액 변수의 값을 수정한다거나 API 요청을 보내는 등, 함수 외부의 상태를 변경시키는~~ 부수효과를 발생시키지 않아야 한다. 즉, 함수 외부의 상태를 변경시키면 안된다.
또한 순수 함수는 동일한 인수에 대해 항상 같은 값을 반환해야 한다. 반환값을 계산할 때, `랜덤함수`나 같은 인수를 입력해도 호출하는 시점에 따라 다른 값을 반환하는 `시간 함수`를 이용하면 순수 함수가 아니다. 

```js
sayHello1('홍길동'); // 시간 함수 예시
sayHello2('홍길동', '11:30');
// return: 홍길동님 안녕하세요. 지금은 11시 30분입니다.
```
여기서 `sayHello2()` 함수는 같은 인수를 입력하면 항상 같은 값을 반환하는 순수 함수이다. 이러한 특성 덕분에 순수 함수는 테스트 코드를 작성하기도 쉽다.

```js
// 테스트 코드
const now = new Date();
const hour = now.getHours();
const minute = now.getMinutes();

expect(sayHello1('홍길동').toBe(
  `홍길동님 안녕하세요. 지금은 ${hour}시 ${minute}분입니다.`,
);

expect(sayHello2('홍길동', '11:30').toBe(
  `홍길동님 안녕하세요. 지금은 11시 30분입니다.`
);
```

시간함수를 사용한 `sayHello1()`함수는 내부적으로 현재 시각을 사용하기 때문에 테스트 코드에서도 현재 시각을 가져와야 한다. 하지만 현재 시각을 가져오는 시점이 서로 다르기 때문에 때때로 테스트가 실패할 수 있다. 하지만 순수 함수로 작성한 코드는 별다른 고민 없이 쉽게 테스트 코드를 작성할 수 있다.

**리듀서**또한 순수 함수이기 때문에 동일한 상탯값과 액션객체를 입력하면 항상 같은 상탯값을 반환한다. 따라서 실행된 액션 객체를 순서대로 저장했다가 나중에 같은 순서로 dispatch() 메서드를 호출하면 쉽게 replay 기능을 구현할 수 있다.

> Q. replay 기능이란